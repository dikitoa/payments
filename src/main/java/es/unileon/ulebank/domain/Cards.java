package es.unileon.ulebank.domain;

import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.persistence.Column;
import javax.persistence.DiscriminatorColumn;
import javax.persistence.DiscriminatorType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToOne;
import javax.persistence.PrimaryKeyJoinColumn;
import javax.persistence.Table;

import org.hibernate.annotations.GenericGenerator;
import org.hibernate.annotations.Parameter;

import es.unileon.ulebank.client.Client;
import es.unileon.ulebank.handler.Handler;
import es.unileon.ulebank.payments.exceptions.IncorrectLengthException;
import es.unileon.ulebank.payments.exceptions.PaymentException;
import es.unileon.ulebank.utils.CardProperties;

/**
 * Cards generated by hbm2java
 */
@Entity
@Table(name = "CARDS", catalog = "ULEBANK_FINAL")
@DiscriminatorColumn(name = "discriminator", discriminatorType = DiscriminatorType.STRING)
public class Cards implements java.io.Serializable {

	private static final long serialVersionUID = 1L;
	private String id;
	private Client client;
	private Handler genericHandler;
	private Accounts accounts;
	private String pin;
	private double buyLimitDiary;
	private double buyLimitMonthly;
	private double cashLimitDiary;
	private double cashLimitMonthly;
	private String emissionDate;
	private String expirationDate;
	private String cvv;
	private int fees;

	public Cards() {
		this.pin = generatePinCode();
		this.emissionDate = generateEmissionDate();
		this.expirationDate = generateExpirationDate();
	}

	/**
	 * // * Constructor de la clase que crea una nueva tarjeta // * // * @param
	 * properties // * @param cardId // * @param type // * @param buyLimitDiary
	 * // * @param buyLimitMonthly // * @param cashLimitDiary // * @param
	 * cashLimitMonthly // * @param commissionEmission // * @param
	 * commissionMaintenance // * @param commissionRenovate //
	 */
	public Cards(Handler cardId, Accounts account, Client Client) {
		this.genericHandler = cardId;
		this.accounts = account;
		this.client = Client;
		this.id = cardId.toString();
		this.pin = generatePinCode();
		this.cvv = generateCVV();
		this.emissionDate = generateEmissionDate();
		this.expirationDate = generateExpirationDate();
	}

	/**
	 * Genera el codigo pin de la tarjeta
	 * 
	 * @return String
	 */
	public String generatePinCode() {
		final StringBuilder result = new StringBuilder();
		// Generamos tantos numeros aleatorios como indique la constante
		// PIN_SIZE para formar el codigo PIN
		for (int i = 0; i < CardProperties.getPinSize(); i++) {
			result.append((int) (Math.random() * 10));
		}

		return result.toString();
	}

	/**
	 * Genera la fecha de emision de la tarjeta
	 * 
	 * @return String
	 */
	public String generateEmissionDate() {
		// Generamos la fecha dandole el formato estandar dd/MM/yyyy
		final SimpleDateFormat dateFormat = new SimpleDateFormat("dd/MM/yyyy");

		return dateFormat.format(new Date());
	}

	/**
	 * Genera una fecha de caducidad para la tarjeta
	 * 
	 * @return String
	 */
	public String generateExpirationDate() {
		// Obtenemos una instancia del calendario
		final Calendar calendar = Calendar.getInstance();

		// Obtenemos el mes actual que sera devuelto en forma de int comenzando
		// en 0 (Enero) por tanto debemos sumarle 1
		String month = Integer.toString(calendar.get(Calendar.MONTH) + 1);
		// Si el mes esta entre enero y septiembre agnadimos un 0 delante al
		// String para que tenga 2 cifras
		if (month.length() == 1) {
			month = "0" + month;
		}

		// Obtenemos el agno actual y cortamos el substring para coger
		// unicamente las dos ultimas cifras
		final String year = Integer.toString(
				CardProperties.getExpirationYear()
						+ calendar.get(Calendar.YEAR)).substring(2);
		// Devolvemos el String con el formato MM/yy
		return month + "/" + year;
	}

	/**
	 * Genera el codigo de validacion CVV
	 * 
	 * @return String
	 */
	public String generateCVV() {
		final StringBuilder result = new StringBuilder();
		// Generamos tantos numeros aleatorios como indique la constante
		// CVV_SIZE para formar el codigo CVV
		for (int i = 0; i < CardProperties.getCvvSize(); i++) {
			result.append((int) (Math.random() * 10));
		}

		return result.toString();
	}

	@GenericGenerator(name = "generator", strategy = "foreign", parameters = @Parameter(name = "property", value = "genericHandler"))
	@Id
	@GeneratedValue(generator = "generator")
	@Column(name = "id", unique = true, nullable = false, length = 64)
	public String getId() {
		return this.id;
	}

	public void setId(String id) {
		this.id = id;
	}

	@ManyToOne(fetch = FetchType.EAGER)
	@JoinColumn(name = "client_id", nullable = false)
	public Client getClient() {
		return this.client;
	}

	public void setClient(Client Client) {
		this.client = Client;
	}

	@OneToOne(fetch = FetchType.EAGER)
	@PrimaryKeyJoinColumn
	public Handler getGenericHandler() {
		return this.genericHandler;
	}

	public void setGenericHandler(Handler genericHandler) {
		this.genericHandler = genericHandler;
	}

	@ManyToOne(fetch = FetchType.EAGER)
	@JoinColumn(name = "account_number", nullable = false)
	public Accounts getAccounts() {
		return this.accounts;
	}

	public void setAccounts(Accounts accounts) {
		this.accounts = accounts;
	}

	@Column(name = "pin", nullable = false, length = 64)
	public String getPin() {
		return this.pin;
	}

	public void setPin(String pin) {
		this.pin = pin;
	}

	/**
	 * Comprueba que el pin sea correcto
	 * 
	 * @param pin
	 * @return boolean
	 */
	public boolean checkPin(String pin) {

		return pin.equals(this.pin);
	}

	@Column(name = "buy_limit_diary", nullable = false, precision = 22, scale = 0)
	public double getBuyLimitDiary() {
		return this.buyLimitDiary;
	}

	public void setBuyLimitDiary(double newAmount) {
		this.buyLimitDiary = newAmount;
	}

	/**
	 * Comprueba que el precio no exceda el limite de la tarjeta
	 * 
	 * @param price
	 * @return boolean
	 */
	public boolean checkBuyLimitDiary(double price) {
		// Si el precio es mayor que el limite de compra diario devuelve false
		return !(price > this.buyLimitDiary);
	}

	@Column(name = "buy_limit_monthly", nullable = false, precision = 22, scale = 0)
	public double getBuyLimitMonthly() {
		return this.buyLimitMonthly;
	}

	public void setBuyLimitMonthly(double newAmount) {
		this.buyLimitMonthly = newAmount;
	}

	@Column(name = "cash_limit_diary", nullable = false, precision = 22, scale = 0)
	public double getCashLimitDiary() {
		return this.cashLimitDiary;
	}

	public void setCashLimitDiary(double newAmount) {
		this.cashLimitDiary = newAmount;
	}

	/**
	 * Comprueba que la cantidad solicitada para extraer en cajero no exceda el
	 * limite de la tarjeta
	 * 
	 * @param cash
	 * @return boolean
	 */
	public boolean checkCashLimitDiary(double cash) {
		return !(cash > this.cashLimitDiary);
	}

	@Column(name = "cash_limit_monthly", nullable = false, precision = 22, scale = 0)
	public double getCashLimitMonthly() {
		return this.cashLimitMonthly;
	}

	public void setCashLimitMonthly(double newAmount) {
		this.cashLimitMonthly = newAmount;
	}

	@Column(name = "emission_date", nullable = false, length = 64)
	public String getEmissionDate() {
		return this.emissionDate;
	}

	public void setEmissionDate(String emissionDate) {
		this.emissionDate = emissionDate;
	}

	@Column(name = "expiration_date", nullable = false, length = 64)
	public String getExpirationDate() {
		return this.expirationDate;
	}

	public void setExpirationDate(String expirationDate) {
		this.expirationDate = expirationDate;
	}

	@Column(name = "cvv", nullable = false, length = 64)
	public String getCvv() {
		return this.cvv;
	}

	public void setCvv(String cvv) throws IncorrectLengthException {
		if (this.checkStringNumber(cvv)) {
			if (cvv.length() == CardProperties.getCvvSize()) {
				this.cvv = cvv;
			} else {
				throw new IncorrectLengthException("Incorrect length");
			}
		} else {
			throw new NumberFormatException(
					"The cvv must only contains numbers");
		}
	}

	@Column(name = "fees", nullable = false)
	public int getFees() {
		return this.fees;
	}

	public void setFees(int fees) {
		this.fees = fees;
	}

	public void makeTransaction(double quantity, String payConcept)
			throws PaymentException {

	}

	/**
	 * Comprueba que el String recibido sea solo numerico
	 * 
	 * @param string
	 * @return boolean
	 */
	private boolean checkStringNumber(String string) {
		// Crea un patron para indicar que solo debe contener numeros
		final Pattern pattern = Pattern.compile("^[0-9]*$");
		// Comprueba que el String recibido cumple el patron
		final Matcher matcher = pattern.matcher(string);

		// Si se cumple el patron devuelve true
		return matcher.find();

	}
}

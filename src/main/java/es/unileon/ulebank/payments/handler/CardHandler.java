package es.unileon.ulebank.payments.handler;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.persistence.DiscriminatorColumn;
import javax.persistence.DiscriminatorType;
import javax.persistence.DiscriminatorValue;
import javax.persistence.Entity;
import javax.persistence.Table;

import es.unileon.ulebank.handler.Handler;
import es.unileon.ulebank.handler.MalformedHandlerException;

/**
 * @author Israel
 */
@Entity
@Table(name = "GENERIC_HANDLER", catalog = "ULEBANK_FINAL")
@DiscriminatorColumn(name = "discriminator", discriminatorType = DiscriminatorType.STRING)
@DiscriminatorValue(value = "CardHandler")
public class CardHandler extends Handler {
    /**
     * 
     */
    private static final long serialVersionUID = 1L;
    /**
     * Cantidad de digitos de la tarjeta
     */
    private static final int CARD_LENGTH = 16;

    public CardHandler() {
        
    }

    /**
     * Constructor de la clase que crea un CardHandler a partir del String
     * recibido
     * 
     * @param number
     * @throws MalformedHandlerException
     */
    public CardHandler(String number) throws MalformedHandlerException {
        final StringBuilder errors = new StringBuilder();
        final Pattern pattern = Pattern.compile("^[0-9]*$");
        final Matcher matcher = pattern.matcher(number);

        if (number.isEmpty()) {
            errors.append("Null card number.");
        } else if (number.length() != CARD_LENGTH - 1) {
            errors.append("Card number must contains 15 digits because digit 16 is autogenerated.");
        } else if (!matcher.find()) {
            errors.append("Card number must only contains numbers.\n");
        }

        if (errors.length() != 0) {
            throw new MalformedHandlerException(errors.toString());
        }
        this.separateNumber(number);
    }

    public CardHandler(Handler handler) throws MalformedHandlerException {
        this(handler.toString());
    }


    /**
     * Metodo para separar los distintos componentes del numero de la tarjeta
     * 
     * @param number
     * @throws MalformedHandlerException
     */
    private void separateNumber(String number) throws MalformedHandlerException {
        number = number + this.generateControlDigit(this
                .stringToIntArray(number));
        this.setId(number);
    }

    /**
     * Convierte el String que recibe a un array de enteros
     * 
     * @param string
     * @return
     */
    private int[] stringToIntArray(String string) {
        final int[] result = new int[string.length()];
        String substring;

        for (int i = 0; i < string.length(); i++) {
            if (i != string.length()) {
                substring = string.substring(i, i + 1);
            } else {
                substring = string.substring(i);
            }
            result[i] = Integer.parseInt(substring);
        }

        return result;
    }

    /**
     * Genera el digito de control empleando el algoritmo de Luhn
     * 
     * @param digits
     * @return int
     */
    protected int generateControlDigit(int[] digits) {
        return (10 - this.verifyCardNumber(digits)) % 10;
    }

    /**
     * Verifica que el numero de tarjeta es correcto si el resultado es 0,
     * tambien se puede emplear para generar el digito de control realizando la
     * operacion 10-verifyCardNumber(digits[])
     * 
     * @param digits
     * @return int
     */
    protected int verifyCardNumber(int[] digits) {
        return (this.sumOddPlaces(digits) + this.sumEvenPlaces(digits)) % 10;
    }

    /**
     * Realiza la suma de las posiciones impares de izquierda a derecha del
     * numero de la tarjeta
     * 
     * @param digits
     * @return int
     */
    private int sumOddPlaces(int[] digits) {
        int sum = 0;
        // Recorremos las posiciones impares
        for (int i = 0; i < digits.length; i += 2) {
            // Doblamos el digito y lo guardamos
            final int aux = digits[i] << 1;
            // Si el numero tiene 2 digitos los sumamos juntos
            if (aux >= 10) {
                sum += (1 + aux) - 10;
            } else {
                sum += aux;
            }
        }

        return sum;
    }

    /**
     * Realiza la suma de las posiciones pares de izquierda a derecha del numero
     * de la tarjeta
     * 
     * @param digits
     * @return int
     */
    private int sumEvenPlaces(int[] digits) {
        int sum = 0;
        // Recorremos las posiciones pares y sumamos los digitos
        for (int i = 1; i < digits.length; i += 2) {
            sum += digits[i];
        }

        return sum;
    }


}
